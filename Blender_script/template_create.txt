import bpy
import numpy as np
import os
import pickle
import json
def save_pkl(path, result):
    """"
    save pkl file
    """
    folder = os.path.dirname(path)
    if not os.path.exists(folder):
        os.makedirs(folder)

    with open(path, 'wb') as result_file:
        pickle.dump(result, result_file, protocol=2)

def get_bone_matrix(a):
    bone_mat = []
    bone_name = []
    for bone in a.pose.bones:
        bone_name.append(bone.name)
        bone_mat.append(np.array(bone.matrix))

    return np.array(bone_mat), bone_name
def get_bone_coordinates(ob_main,a):
    joints_matrix = np.zeros((6, 34))
    
    #for bone in bpy.data.objects["Armature"].pose.bones:
    skeleton = "Armature"
    R = bpy.data.objects[skeleton].matrix_world.to_3x3()
    R = np.array(R)

    t = bpy.data.objects[skeleton].matrix_world.translation
    t = np.array(t) 

    
    for bone in bpy.data.objects['Armature'].data.bones:
    
        local_location = bone.head_local
        local_location_tail = bone.tail_local
        local_location_tail = np.array(local_location_tail)
        loc_tail = np.dot(R, local_location_tail) + t
        
        
        
        local_location = np.array(local_location)
        loc = np.dot(R, local_location) + t 
        #loc = local_location
        parts = bone.name.split('.')
        
        
        
        print("bone name:",bone.name)
        print("bone location: ", loc)
        bone_head =  loc
        bone_tail =  loc_tail
        if(len(parts) == 1):
            joints_matrix[0][0] = bone_head[0]
            joints_matrix[1][0] = bone_head[1]
            joints_matrix[2][0] = bone_head[2]
            joints_matrix[3][0] = bone_tail[0]
            joints_matrix[4][0] = bone_tail[1]
            joints_matrix[5][0] = bone_tail[2]
        else:
            index = int(parts[1])
            joints_matrix[0][index] = bone_head[0]
            joints_matrix[1][index] = bone_head[1]
            joints_matrix[2][index] = bone_head[2]
            joints_matrix[3][index] = bone_tail[0]
            joints_matrix[4][index] = bone_tail[1]
            joints_matrix[5][index] = bone_tail[2]
    
    return joints_matrix
def get_vertices(me, ob_main):
    me_verts = me.vertices[:]

    vertices = [(ob_main.matrix_world @ me_verts.co).to_tuple() for me_verts in me_verts]

    return np.array(vertices)


def get_faces(me):
    me_verts = me.vertices[:]
    face_index_pairs = [(face, index) for index, face in enumerate(me.polygons)]
    face_index = []
    for f, f_index in face_index_pairs:
        f_v = [(vi, me_verts[v_idx], l_idx)
            for vi, (v_idx, l_idx) in enumerate(zip(f.vertices, f.loop_indices))]
        t = []
        for vi, v, li in f_v:
            t.append(v.index)
        face_index.append(t)
    return np.array(face_index)

def get_weights(me, num_bone):
    me_verts = me.vertices[:]
    
    weights = []
    for v in me_verts:
        temp = np.zeros((num_bone,))
        for g in v.groups:
            temp[g.group] = g.weight
       
        # we can not get the weight less than a threshold
        # so, normalize weights
        temp = temp/np.sum(temp)
        weights.append(temp)
    return np.array(weights, dtype=np.float64)

if __name__ == "__main__":
    # the name of the skeleton and the mesh are defined by users
    data = {}
    skeleton = "Armature"
    mesh = "Icosphere.001"
    # the skeleton hierarchy is defined by users
    # you can change the order according to your skeleton
    #data['hierarchies'] = [-1,0,1,2,1,4,5,6,1,8,9,10,0,12,13,14,0,16,17,18]

    a = bpy.data.objects[skeleton]
    
    ob_main = bpy.data.objects[mesh]
 
    
    
    if bpy.app.version[0] == 2 and bpy.app.version[1] > 80:
        depsgraph = bpy.context.evaluated_depsgraph_get()
        me = ob_main.to_mesh(preserve_all_data_layers=True, depsgraph=depsgraph)
    elif bpy.app.version[0] == 2 and bpy.app.version[1] > 70:
        depsgraph = bpy.context.scene
        me = ob_main.to_mesh(depsgraph, True, 'RENDER')
    elif bpy.app.version[0] > 2:
        depsgraph = bpy.context.scene
        me = ob_main.to_mesh(preserve_all_data_layers=False, depsgraph=None)
        
    
    # get bones
    data['bones'], data['bone_name'] = get_bone_matrix(a)
    print(data['bones'])
    # get vertices
    data['v_template'] = get_vertices(me, ob_main)

    # get facess
    data['faces'] = get_faces(me)
    
    print(data['faces'])
    
    data['joints_matrix'] = get_bone_coordinates(ob_main,a)
    # get weights
    data['weights'] = get_weights(me, len(data['bones']))
    
    data['weights_mask'] = np.copy(data['weights'])
    for row in range(data['weights_mask'].shape[0]):
        for col in range(data['weights_mask'].shape[1]):
            if(data['weights_mask'][row][col] != 0):
                data['weights_mask'][row][col] = 1
            
    print(data['weights_mask']) 
            
    #save_pkl('/SoftRas/avian-mesh/models/new_bat_params_version2_forward_membrane.pkl', data)
    save_pkl('/SoftRas/models/new_bat_params_version2_foreward_membrane.pkl', data)

    

